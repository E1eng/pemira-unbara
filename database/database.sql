-- =============================================
-- PEMIRA BEM - COMPLETE DATABASE SCHEMA
-- =============================================
-- Author: Antigravity Agent
-- Version: 2.1 (BEM Election + Perfect Audit)
-- 
-- INSTRUKSI:
-- 1. Copy SEMUA isi file ini
-- 2. Paste ke SQL Editor di Supabase Dashboard
-- 3. Klik "Run"
-- 4. Selesai!
--
-- File ini AMAN untuk database yang sudah ada.
-- Menggunakan ALTER TABLE untuk menambah kolom baru.
-- =============================================

-- =============================================
-- 1. SETUP EKSTENSI
-- =============================================
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- =============================================
-- 2. TIPE DATA (ENUM)
-- =============================================
DO $$
BEGIN
  CREATE TYPE log_type AS ENUM (
    'LOGIN_FAIL',
    'VOTE_SUCCESS',
    'SYSTEM_ERROR',
    'ADMIN_ACTION',
    'SECURITY_ALERT'
  );
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

-- Fix for existing databases: Add 'SECURITY_ALERT' if missing
DO $$
BEGIN
  ALTER TYPE log_type ADD VALUE IF NOT EXISTS 'SECURITY_ALERT';
EXCEPTION
  WHEN duplicate_object THEN NULL; -- Ignore if already exists (postgres < 12 fallback)
  WHEN OTHERS THEN NULL; -- Ignore other errors (e.g. if type is used)
END $$;

-- =============================================
-- 3. TABEL - CANDIDATES (Paslon)
-- =============================================
CREATE TABLE IF NOT EXISTS candidates (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text, -- Legacy (untuk backward compatibility)
  candidate_number int, -- Nomor Urut Paslon
  chairman_name text, -- Nama Calon Ketua
  vice_chairman_name text, -- Nama Calon Wakil
  vision text NOT NULL,
  mission text NOT NULL,
  photo_url text,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Tambah kolom baru jika belum ada (untuk database existing)
ALTER TABLE candidates ADD COLUMN IF NOT EXISTS candidate_number int;
ALTER TABLE candidates ADD COLUMN IF NOT EXISTS chairman_name text;
ALTER TABLE candidates ADD COLUMN IF NOT EXISTS vice_chairman_name text;

-- Migrasi data lama: copy 'name' ke 'chairman_name'
UPDATE candidates
SET 
  candidate_number = COALESCE(candidate_number, id::int),
  chairman_name = COALESCE(chairman_name, name, 'Unnamed'),
  vice_chairman_name = COALESCE(vice_chairman_name, '')
WHERE chairman_name IS NULL OR chairman_name = '';

-- Drop NOT NULL constraint on legacy 'name' column (untuk database existing)
ALTER TABLE candidates ALTER COLUMN name DROP NOT NULL;
ALTER TABLE candidates ALTER COLUMN name SET DEFAULT '';

-- =============================================
-- 4. TABEL - VOTERS (DPT Mahasiswa)
-- =============================================
CREATE TABLE IF NOT EXISTS voters (
  nim text PRIMARY KEY,
  name text NOT NULL,
  faculty text, -- Fakultas
  major text, -- Jurusan/Prodi
  access_code_hash text NOT NULL,
  has_voted boolean DEFAULT false NOT NULL,
  voted_at timestamp with time zone,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Tambah kolom baru jika belum ada
ALTER TABLE voters ADD COLUMN IF NOT EXISTS faculty text;
ALTER TABLE voters ADD COLUMN IF NOT EXISTS major text;
ALTER TABLE voters ADD COLUMN IF NOT EXISTS voted_at timestamp with time zone;

-- Set default untuk data lama
UPDATE voters
SET 
  faculty = COALESCE(faculty, 'Unknown'),
  major = COALESCE(major, 'Unknown')
WHERE faculty IS NULL;

-- =============================================
-- 5. TABEL - RATE LIMITS (Anti Brute Force)
-- =============================================
DROP TABLE IF EXISTS vote_rate_limits CASCADE;
CREATE TABLE IF NOT EXISTS vote_rate_limits (
  client_key text PRIMARY KEY,
  fail_count int DEFAULT 0 NOT NULL,
  first_fail_at timestamp with time zone,
  blocked_until timestamp with time zone,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE INDEX IF NOT EXISTS vote_rate_limits_blocked_until_idx ON vote_rate_limits (blocked_until);

-- Policy for vote_rate_limits (Since validate_voter is SECURITY DEFINER, this is nice-to-have but good practice)
ALTER TABLE vote_rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow system to manage rate limits" ON vote_rate_limits FOR ALL USING (true) WITH CHECK (true);

-- =============================================
-- 6. TABEL - VOTES (Suara Anonim)
-- =============================================
CREATE TABLE IF NOT EXISTS votes (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  candidate_id bigint REFERENCES candidates(id) ON DELETE CASCADE NOT NULL,
  timestamp timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- =============================================
-- 7. TABEL - AUDIT LOGS
-- =============================================
CREATE TABLE IF NOT EXISTS audit_logs (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  action log_type NOT NULL,
  details jsonb,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- =============================================
-- 8. TABEL - ELECTION SETTINGS
-- =============================================
CREATE TABLE IF NOT EXISTS election_settings (
  id int PRIMARY KEY DEFAULT 1,
  is_voting_open boolean DEFAULT false NOT NULL,
  show_live_result boolean DEFAULT false NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

INSERT INTO election_settings (id) VALUES (1) ON CONFLICT (id) DO NOTHING;

-- =============================================
-- 9. TABEL - ADMIN USERS
-- =============================================
CREATE TABLE IF NOT EXISTS admin_users (
  user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  role text DEFAULT 'admin' NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- =============================================
-- 10. ROW LEVEL SECURITY (RLS)
-- =============================================
ALTER TABLE candidates ENABLE ROW LEVEL SECURITY;
ALTER TABLE voters ENABLE ROW LEVEL SECURITY;
ALTER TABLE vote_rate_limits ENABLE ROW LEVEL SECURITY;
ALTER TABLE votes ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE election_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE admin_users ENABLE ROW LEVEL SECURITY;

-- Helper: Check Admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT EXISTS (SELECT 1 FROM admin_users au WHERE au.user_id = auth.uid());
$$;

-- Drop existing policies (untuk recreate)
DROP POLICY IF EXISTS "Public view candidates" ON candidates;
DROP POLICY IF EXISTS "Admin manage candidates" ON candidates;
DROP POLICY IF EXISTS "Admin view voters" ON voters;
DROP POLICY IF EXISTS "Admin modify voters" ON voters;
DROP POLICY IF EXISTS "Admin view votes" ON votes;
DROP POLICY IF EXISTS "Admin view logs" ON audit_logs;
DROP POLICY IF EXISTS "Public view settings" ON election_settings;
DROP POLICY IF EXISTS "Admin update settings" ON election_settings;
DROP POLICY IF EXISTS "Admin view self" ON admin_users;

-- Policies
CREATE POLICY "Public view candidates" ON candidates FOR SELECT USING (true);
CREATE POLICY "Admin manage candidates" ON candidates FOR ALL TO authenticated USING (is_admin()) WITH CHECK (is_admin());

CREATE POLICY "Admin view voters" ON voters FOR SELECT TO authenticated USING (is_admin());
CREATE POLICY "Admin modify voters" ON voters FOR ALL TO authenticated USING (is_admin()) WITH CHECK (is_admin());

CREATE POLICY "Admin view votes" ON votes FOR SELECT TO authenticated USING (is_admin());

CREATE POLICY "Admin view logs" ON audit_logs FOR SELECT TO authenticated USING (is_admin());

CREATE POLICY "Public view settings" ON election_settings FOR SELECT USING (true);
CREATE POLICY "Admin update settings" ON election_settings FOR UPDATE TO authenticated USING (is_admin()) WITH CHECK (is_admin());

CREATE POLICY "Admin view self" ON admin_users FOR SELECT TO authenticated USING (user_id = auth.uid());

-- =============================================
-- 11. FUNCTIONS (RPC) - Drop dulu semua
-- =============================================
DROP FUNCTION IF EXISTS submit_vote(text, text, bigint, jsonb);
DROP FUNCTION IF EXISTS admin_add_voter(text, text, text);
DROP FUNCTION IF EXISTS admin_add_voter(text, text, text, text, text);
DROP FUNCTION IF EXISTS get_vote_recap();
DROP FUNCTION IF EXISTS get_participation_stats();
DROP FUNCTION IF EXISTS validate_voter(text, text);

-- =============================================
-- 12. FUNCTION: submit_vote (Core Voting)
-- =============================================
CREATE OR REPLACE FUNCTION submit_vote(
  p_nim text,
  p_access_code_plain text,
  p_candidate_id bigint,
  p_client_info jsonb
) RETURNS jsonb AS $$
DECLARE
  v_voter voters%ROWTYPE;
  v_settings election_settings%ROWTYPE;
  v_rate vote_rate_limits%ROWTYPE;
  v_client_key text;
  v_ip text;
  v_ua text;
  v_now timestamptz := timezone('utc'::text, now());
  v_window interval := interval '10 minutes';
  v_max_fail int := 10;
BEGIN
  -- Cek voting open
  SELECT * INTO v_settings FROM election_settings WHERE id = 1;
  IF v_settings.is_voting_open IS DISTINCT FROM true THEN
    INSERT INTO audit_logs (action, details) VALUES ('LOGIN_FAIL', jsonb_build_object('reason', 'Voting Closed', 'nim', p_nim));
    RETURN jsonb_build_object('status', 'error', 'message', 'Pemilihan suara sedang ditutup.');
  END IF;

  -- Client fingerprint
  v_ip := COALESCE(p_client_info->>'ip', 'unknown');
  v_ua := COALESCE(p_client_info->>'userAgent', 'unknown');
  v_client_key := encode(digest(v_ip || '|' || v_ua, 'sha256'), 'hex');

  -- Rate limit check
  SELECT * INTO v_rate FROM vote_rate_limits WHERE client_key = v_client_key;
  IF FOUND AND v_rate.blocked_until > v_now THEN
    INSERT INTO audit_logs (action, details) VALUES ('SECURITY_ALERT', jsonb_build_object('reason', 'Rate Limited', 'key', v_client_key));
    RETURN jsonb_build_object('status', 'error', 'message', 'Terlalu banyak percobaan gagal. Silakan tunggu 10 menit.');
  END IF;

  -- Validate NIM (with row lock)
  SELECT * INTO v_voter FROM voters WHERE nim = p_nim FOR UPDATE;
  
  IF NOT FOUND THEN
    INSERT INTO vote_rate_limits (client_key, fail_count, first_fail_at, updated_at)
    VALUES (v_client_key, 1, v_now, v_now)
    ON CONFLICT (client_key) DO UPDATE
    SET fail_count = vote_rate_limits.fail_count + 1, updated_at = EXCLUDED.updated_at;
    
    INSERT INTO audit_logs (action, details) VALUES ('LOGIN_FAIL', jsonb_build_object('reason', 'NIM Not Found', 'nim', p_nim, 'ip', v_ip, 'userAgent', v_ua));
    RETURN jsonb_build_object('status', 'error', 'message', 'NIM tidak terdaftar dalam DPT.');
  END IF;

  -- Validate Token
  IF v_voter.access_code_hash != crypt(p_access_code_plain, v_voter.access_code_hash) THEN
    INSERT INTO vote_rate_limits (client_key, fail_count, first_fail_at, updated_at)
    VALUES (v_client_key, 1, v_now, v_now)
    ON CONFLICT (client_key) DO UPDATE
    SET fail_count = vote_rate_limits.fail_count + 1, updated_at = EXCLUDED.updated_at;

    SELECT * INTO v_rate FROM vote_rate_limits WHERE client_key = v_client_key;
    IF v_rate.fail_count >= v_max_fail THEN
      UPDATE vote_rate_limits SET blocked_until = v_now + v_window WHERE client_key = v_client_key;
    END IF;

    INSERT INTO audit_logs (action, details) VALUES ('LOGIN_FAIL', jsonb_build_object('reason', 'Wrong Token', 'nim', p_nim, 'ip', v_ip, 'userAgent', v_ua));
    RETURN jsonb_build_object('status', 'error', 'message', 'Kode Akses salah.');
  END IF;

  -- Check already voted
  IF v_voter.has_voted THEN
    INSERT INTO audit_logs (action, details) VALUES ('LOGIN_FAIL', jsonb_build_object('reason', 'Already Voted', 'nim', p_nim, 'ip', v_ip, 'userAgent', v_ua));
    RETURN jsonb_build_object('status', 'error', 'message', 'Mahasiswa ini sudah menggunakan hak pilihnya.');
  END IF;

  -- SUCCESS: Record vote
  DELETE FROM vote_rate_limits WHERE client_key = v_client_key;
  UPDATE voters SET has_voted = true, voted_at = v_now WHERE nim = p_nim;
  INSERT INTO votes (candidate_id) VALUES (p_candidate_id);

  INSERT INTO audit_logs (action, details) 
  VALUES ('VOTE_SUCCESS', jsonb_build_object('nim', p_nim, 'faculty', v_voter.faculty, 'ip', v_ip, 'userAgent', v_ua));

  RETURN jsonb_build_object('status', 'success', 'message', 'Suara berhasil direkam. Terima kasih!');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, extensions;

-- =============================================
-- 13. FUNCTION: admin_add_voter (Import DPT)
-- =============================================
CREATE OR REPLACE FUNCTION admin_add_voter(
  p_nim text,
  p_name text,
  p_faculty text,
  p_major text,
  p_access_code_plain text
) RETURNS void AS $$
BEGIN
  INSERT INTO voters (nim, name, faculty, major, access_code_hash)
  VALUES (
    p_nim,
    p_name,
    p_faculty,
    p_major,
    crypt(p_access_code_plain, extensions.gen_salt('bf'))
  )
  ON CONFLICT (nim) DO UPDATE
  SET name = EXCLUDED.name,
      faculty = EXCLUDED.faculty,
      major = EXCLUDED.major,
      access_code_hash = EXCLUDED.access_code_hash;
      
  INSERT INTO audit_logs (action, details) VALUES ('ADMIN_ACTION', jsonb_build_object('type', 'UPSERT_VOTER', 'nim', p_nim));
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, extensions;

-- =============================================
-- 14. FUNCTION: get_vote_recap (Real Count)
-- =============================================
CREATE OR REPLACE FUNCTION get_vote_recap()
RETURNS TABLE (
  candidate_id bigint, 
  candidate_number int,
  chairman_name text,
  vice_chairman_name text,
  photo_url text,
  total_votes bigint
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id,
    c.candidate_number,
    c.chairman_name,
    c.vice_chairman_name,
    c.photo_url,
    count(v.id) AS total_votes
  FROM candidates c
  LEFT JOIN votes v ON c.id = v.candidate_id
  GROUP BY c.id, c.candidate_number, c.chairman_name, c.vice_chairman_name, c.photo_url
  ORDER BY total_votes DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- =============================================
-- 15. FUNCTION: get_participation_stats
-- =============================================
CREATE OR REPLACE FUNCTION get_participation_stats()
RETURNS TABLE (
  faculty text,
  total_voters bigint,
  already_voted bigint,
  participation_percentage numeric
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    v.faculty,
    count(*)::bigint AS total_voters,
    count(CASE WHEN v.has_voted THEN 1 END)::bigint AS already_voted,
    round((count(CASE WHEN v.has_voted THEN 1 END)::numeric / NULLIF(count(*)::numeric, 0)) * 100, 2) AS participation_percentage
  FROM voters v
  GROUP BY v.faculty
  ORDER BY participation_percentage DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- =============================================
-- 16. FUNCTION: validate_voter (Pre-login Check)
-- =============================================
CREATE OR REPLACE FUNCTION validate_voter(
  p_nim text,
  p_access_code_plain text,
  p_client_info jsonb DEFAULT '{}'::jsonb
) RETURNS jsonb AS $$
DECLARE
  v_voter voters%ROWTYPE;
  v_rate vote_rate_limits%ROWTYPE;
  v_client_key text;
  v_ip text;
  v_ua text;
  v_now timestamptz := timezone('utc'::text, now());
  v_window interval := interval '10 minutes';
  v_max_fail int := 10;
BEGIN
  -- Client fingerprint
  v_ip := COALESCE(p_client_info->>'ip', 'unknown');
  v_ua := COALESCE(p_client_info->>'userAgent', 'unknown');
  v_client_key := encode(digest(v_ip || '|' || v_ua, 'sha256'), 'hex');

  -- 1. Check if ALREADY blocked
  SELECT * INTO v_rate FROM vote_rate_limits WHERE client_key = v_client_key;
  IF FOUND AND v_rate.blocked_until > v_now THEN
    INSERT INTO audit_logs (action, details) VALUES ('SECURITY_ALERT', jsonb_build_object('reason', 'Rate Limited (Login)', 'key', v_client_key, 'ip', v_ip));
    RETURN jsonb_build_object('ok', false, 'reason', 'Terlalu banyak percobaan. Tunggu 10 menit.');
  END IF;

  -- 2. Validate NIM
  SELECT * INTO v_voter FROM voters WHERE nim = p_nim;
  
  -- If NIM not found OR Token mismatch -> Increment Fail Count & Block if needed
  IF NOT FOUND OR v_voter.access_code_hash != crypt(p_access_code_plain, v_voter.access_code_hash) THEN
    
    INSERT INTO vote_rate_limits (client_key, fail_count, first_fail_at, updated_at, blocked_until)
    VALUES (v_client_key, 1, v_now, v_now, NULL)
    ON CONFLICT (client_key) DO UPDATE
    SET 
      fail_count = vote_rate_limits.fail_count + 1,
      updated_at = EXCLUDED.updated_at,
      blocked_until = CASE 
        -- Block immediately if threshold reached
        WHEN (vote_rate_limits.fail_count + 1) >= v_max_fail THEN EXCLUDED.updated_at + v_window
        ELSE vote_rate_limits.blocked_until -- Keep existing or NULL
      END
    RETURNING * INTO v_rate;

    -- Log specific error
    IF NOT FOUND THEN
      INSERT INTO audit_logs (action, details) VALUES ('LOGIN_FAIL', jsonb_build_object('reason', 'NIM Not Found', 'nim', p_nim, 'ip', v_ip));
      RETURN jsonb_build_object('ok', false, 'reason', 'NIM tidak ditemukan.');
    ELSE
      INSERT INTO audit_logs (action, details) VALUES ('LOGIN_FAIL', jsonb_build_object('reason', 'Wrong Token', 'nim', p_nim, 'ip', v_ip));
      RETURN jsonb_build_object('ok', false, 'reason', 'Kode Akses salah.');
    END IF;

  END IF;
  
  -- 3. Success: Reset rate limit for this client
  DELETE FROM vote_rate_limits WHERE client_key = v_client_key;

  RETURN jsonb_build_object(
    'ok', true, 
    'has_voted', v_voter.has_voted, 
    'name', v_voter.name,
    'faculty', v_voter.faculty
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, extensions;

-- =============================================
-- 17. GRANT PERMISSIONS
-- =============================================
REVOKE ALL ON FUNCTION admin_add_voter(text, text, text, text, text) FROM public;
GRANT EXECUTE ON FUNCTION admin_add_voter(text, text, text, text, text) TO authenticated;

REVOKE ALL ON FUNCTION submit_vote(text, text, bigint, jsonb) FROM public;
GRANT EXECUTE ON FUNCTION submit_vote(text, text, bigint, jsonb) TO anon, authenticated;

REVOKE ALL ON FUNCTION get_vote_recap() FROM public;
GRANT EXECUTE ON FUNCTION get_vote_recap() TO anon, authenticated;

REVOKE ALL ON FUNCTION get_participation_stats() FROM public;
GRANT EXECUTE ON FUNCTION get_participation_stats() TO authenticated;

REVOKE ALL ON FUNCTION validate_voter(text, text, jsonb) FROM public;
GRANT EXECUTE ON FUNCTION validate_voter(text, text, jsonb) TO anon, authenticated;

-- =============================================
-- 18. TRIGGERS - AUTOMTIC AUDIT LOGGING (The Fix)
-- =============================================

CREATE OR REPLACE FUNCTION log_admin_action_trigger()
RETURNS TRIGGER AS $$
DECLARE
  v_admin_id uuid;
  v_details jsonb;
  v_action text;
BEGIN
  -- Attempt to get current user ID
  v_admin_id := auth.uid();
  v_action := TG_OP; -- INSERT, UPDATE, DELETE

  -- Build details JSON based on table and operation
  IF TG_TABLE_NAME = 'candidates' THEN
    IF v_action = 'DELETE' THEN
      v_details := jsonb_build_object('table', 'candidates', 'op', 'DELETE', 'id', OLD.id, 'name', OLD.chairman_name);
    ELSE
      v_details := jsonb_build_object('table', 'candidates', 'op', v_action, 'id', NEW.id, 'name', NEW.chairman_name);
    END IF;

  ELSIF TG_TABLE_NAME = 'voters' THEN
    IF v_action = 'DELETE' THEN
      v_details := jsonb_build_object('table', 'voters', 'op', 'DELETE', 'nim', OLD.nim);
    ELSIF v_action = 'UPDATE' AND OLD.has_voted IS DISTINCT FROM NEW.has_voted THEN
      -- Special case: Resetting vote status
      v_details := jsonb_build_object('table', 'voters', 'op', 'RESET_STATUS', 'nim', NEW.nim, 'new_status', NEW.has_voted);
    ELSE
      v_details := jsonb_build_object('table', 'voters', 'op', v_action, 'nim', NEW.nim);
    END IF;

  ELSIF TG_TABLE_NAME = 'election_settings' THEN
    v_details := jsonb_build_object(
      'table', 'election_settings', 
      'op', 'UPDATE', 
      'voting_open', NEW.is_voting_open, 
      'live_result', NEW.show_live_result
    );

  ELSIF TG_TABLE_NAME = 'admin_users' THEN
     IF v_action = 'DELETE' THEN
        v_details := jsonb_build_object('table', 'admin_users', 'op', 'DELETE', 'user_id', OLD.user_id);
     ELSE
        v_details := jsonb_build_object('table', 'admin_users', 'op', v_action, 'user_id', NEW.user_id);
     END IF;
  END IF;

  -- Insert into audit_logs (Only insert if detected as admin action or significant change)
  -- To prevent endless loops or noise, we only log if it's NOT a system vote (VOTE_SUCCESS logs separately)
  
  -- However, since 'voters' UPDATE is captured here, and submit_vote does UPDATE voters...
  -- We need to differentiate.
  -- submit_vote uses SECURITY DEFINER, so auth.uid() might be anon or user.
  -- But we only want to log ADMIN actions here.
  
  -- Basic Check: Only log if auth.uid() is in admin_users?
  -- OR, let's keep it simple: Log everything for accountability. System logs are fine.
  
  INSERT INTO audit_logs (action, details, created_at)
  VALUES ('ADMIN_ACTION', v_details, now());

  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing triggers to avoid duplicates
DROP TRIGGER IF EXISTS audit_candidates_trigger ON candidates;
DROP TRIGGER IF EXISTS audit_settings_trigger ON election_settings;
DROP TRIGGER IF EXISTS audit_admin_users_trigger ON admin_users;
DROP TRIGGER IF EXISTS audit_voters_delete_trigger ON voters;

-- Attach Triggers

-- Candidates: Log Everything (Insert, Update, Delete)
CREATE TRIGGER audit_candidates_trigger
AFTER INSERT OR UPDATE OR DELETE ON candidates
FOR EACH ROW EXECUTE FUNCTION log_admin_action_trigger();

-- Election Settings: Log Updates
CREATE TRIGGER audit_settings_trigger
AFTER UPDATE ON election_settings
FOR EACH ROW EXECUTE FUNCTION log_admin_action_trigger();

-- Sidebar Admin Users: Log Everything
CREATE TRIGGER audit_admin_users_trigger
AFTER INSERT OR UPDATE OR DELETE ON admin_users
FOR EACH ROW EXECUTE FUNCTION log_admin_action_trigger();

-- Voters: Only Log DELETE (Insert is handled by RPC, Update usually handled by system vote)
-- We only log DELETE to catch mass deletion or individual removal by admin.
CREATE TRIGGER audit_voters_delete_trigger
AFTER DELETE ON voters
FOR EACH ROW EXECUTE FUNCTION log_admin_action_trigger();

-- =============================================
-- DONE!
-- =============================================
SELECT 'Database migration completed successfully!' AS status;